package com.borets.pfa.report.revenue;

import com.borets.pfa.entity.activity.RecordType;
import com.borets.pfa.report.custom.Account;
import com.borets.pfa.report.custom.CustomExcelReportTemplate;
import com.borets.pfa.report.custom.HorizontalPosition;
import com.borets.pfa.report.custom.ReportCell;
import com.haulmont.cuba.core.global.AppBeans;
import com.haulmont.cuba.core.global.Messages;
import com.haulmont.cuba.core.global.UserSessionSource;
import com.haulmont.yarg.formatters.impl.xlsx.CellReference;
import com.haulmont.yarg.formatters.impl.xlsx.Document;
import com.haulmont.yarg.structure.BandData;
import org.apache.commons.collections4.BidiMap;
import org.apache.commons.collections4.OrderedBidiMap;
import org.apache.commons.collections4.bidimap.TreeBidiMap;
import org.docx4j.openpackaging.exceptions.Docx4JException;
import org.docx4j.openpackaging.parts.SpreadsheetML.WorksheetPart;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.xlsx4j.jaxb.Context;
import org.xlsx4j.sml.CTAutoFilter;
import org.xlsx4j.sml.CTCellFormula;
import org.xlsx4j.sml.CTMergeCell;
import org.xlsx4j.sml.CTMergeCells;
import org.xlsx4j.sml.CTSheetCalcPr;
import org.xlsx4j.sml.Cell;
import org.xlsx4j.sml.Row;
import org.xlsx4j.sml.STCellType;
import org.xlsx4j.sml.SheetData;
import org.xlsx4j.sml.Worksheet;

import javax.annotation.Nullable;
import java.text.SimpleDateFormat;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * Revenue Report data and logic container.
 */
public class RevenueReportTemplateImpl extends CustomExcelReportTemplate {

    private static final Logger LOGGER = LoggerFactory.getLogger(RevenueReportTemplateImpl.class);

    /**
     * Amount of columns related to Account Description (Account Type, Parent, Customer, Manager and so on).
     */
    private static final int ACCOUNT_INFO_COLUMNS = 6;

    /**
     * Input data params.
     */
    private static final String PARAMS_THRESHOLD_DATE = "dateThreshold";
    private static final String PARAMS_MODE = "mode";
    private static final String DATA_BAND_NAME = "ReportData";

    /**
     * Result DataSet SQL column names.
     */
    private static final String ACCOUNT_TYPE_FIELD = "ACCOUNT_TYPE";
    private static final String ACCOUNT_ORDER_FIELD = "ACCOUNT_ORDER";
    private static final String ACCOUNT_PARENT_FIELD = "PARENT_ACCOUNT_NAME";
    private static final String ACCOUNT_CUSTOMER_FIELD = "ACCOUNT_NAME";
    private static final String ACCOUNT_BUSINESS_MODEL_FIELD = "BUSINESS_MODEL";
    private static final String ACCOUNT_APPLICATION_TYPE_FIELD = "APPLICATION_TYPE";
    private static final String ACCOUNT_MANAGER_FIELD = "ACCOUNT_MANAGER";
    private static final String REVENUE_TYPE_NAME_FIELD = "REVENUE_TYPE_NAME";
    private static final String REVENUE_TYPE_ORDER_FIELD = "REVENUE_TYPE_ORDER";
    private static final String REVENUE_PERIOD_FIELD = "P";
    private static final String REVENUE_VALUE = "REVENUE";

    /**
     * Indices of columns and rows (these values must be correlated with concrete Excel template).
     */
    private static final int ROW_DECORATIVE_IDX = 1;
    private static final int ROW_HEADER_IDX = 2;
    private static final int ROW_SUBHEADER_IDX = 8;
    private static final int ROW_FIRST_DATA_IDX = 9;
    private static final int ROW_SUMMARY_PER_MONTH_IDX = 3;
    private static final int ROW_SUMMARY_IDX = 4;
    private static final int ROW_SUMMARY_STRATEGIC_IDX = 5;
    private static final int ROW_SUMMARY_KEY_IDX = 6;
    private static final int ROW_SUMMARY_OTHER_IDX = 7;
    private static final int COL_HEADER_ODD_STYLE_IDX = 1;
    private static final int COL_HEADER_EVEN_STYLE_IDX = 3;
    private static final int COL_REFERENCE_HEADER_IDX = 3;
    private static final int COL_REFERENCE_SUBHEADER_IDX = 0;

    /**
     * Coordinates of the cell where report signature "Generated by..." will be placed in.
     */
    private static final int SIGN_REPORT_ROW = 0;
    private static final int SIGN_REPORT_COL = 3;


    private final Map<Account, List<HorizontalPosition>> coordinates = new HashMap<>();
    private final List<ReportCell> reportCells = new ArrayList<>();

    // grouping by revenue type
    private final OrderedBidiMap<String, Integer> revenueTypeOrders = new TreeBidiMap<>();
    private final List<Date> dates = new ArrayList<>();

    @Override
    protected void preProcessDataElement(String bandName, BandData dataElement) {
        Map<String, Object> data = dataElement.getData();
        String revenueType = (String) data.get(REVENUE_TYPE_NAME_FIELD);
        // map revenue types to their orders
        revenueTypeOrders.computeIfAbsent(revenueType, String -> (Integer) data.get(REVENUE_TYPE_ORDER_FIELD));
        // get distinct dates of report
        Date d = (Date) data.get(REVENUE_PERIOD_FIELD);
        if (!dates.contains(d)) {
            dates.add(d);
        }
    }

    @Override
    protected void afterPreProcess() {
        // Dates must be sorted in natural order
        Collections.sort(dates);
    }

    @Override
    protected void processDataElement(String bandName, BandData dataElement) {
        if (DATA_BAND_NAME.equals(bandName)) {
            Account x = getAccount(dataElement);
            coordinates.computeIfAbsent(x, Account -> new ArrayList<>());
            List<HorizontalPosition> horizontalPositions = coordinates.get(x);
            HorizontalPosition y = getHorizontalPosition(dataElement);
            if (!horizontalPositions.contains(y)) {
                horizontalPositions.add(y);
            }
            // Getting existing objects instead of newly created
            for (Account a :
                    coordinates.keySet()) {
                if (a.equals(x)) {
                    x = a;
                    break;
                }
            }
            for (HorizontalPosition a :
                    coordinates.get(x)) {
                if (a.equals(y)) {
                    y = a;
                    break;
                }
            }
            // Create new cell
            ReportCell reportCell = ReportCell.newDigit(dataElement.getData().getOrDefault(REVENUE_VALUE, 0), x, y);
            reportCells.add(reportCell);
        }
    }

    @Override
    protected void generateReport() throws Docx4JException {

        Document.SheetWrapper sheetWrapper = document.getWorksheets().get(0);
        String sheetName = sheetWrapper.getName();
        WorksheetPart worksheetPart = sheetWrapper.getWorksheet();
        Worksheet contents = worksheetPart.getContents();
        SheetData sheetData = contents.getSheetData();
        List<Row> rows = sheetData.getRow();
        CTSheetCalcPr ctSheetCalcPr = new CTSheetCalcPr();
        ctSheetCalcPr.setFullCalcOnLoad(true);
        contents.setSheetCalcPr(ctSheetCalcPr);

        Row referenceRow = rows.get(rows.size() - 1);

        // Sorted accounts
        List<Account> orderedAccounts = coordinates.keySet().stream()
                .sorted(Comparator.comparing(Account::getOrder)
                        .thenComparing(Account::getParent, Comparator.nullsLast(Comparator.naturalOrder()))
                        .thenComparing(Account::getCustomer))
                .collect(Collectors.toList());

        // Headers
        Row decorativeRow = rows.get(ROW_DECORATIVE_IDX); // Upper red line without values
        Row dateTitleRow = rows.get(ROW_HEADER_IDX); // Period titles: "Apr 2022", "May 2022", ...
        Row monthSummaryRow = rows.get(ROW_SUMMARY_PER_MONTH_IDX); // Summaries for period

        // Styles for period interleaving (i.g. lighter/darker)
        long oddDateTitleStyle = dateTitleRow.getC().get(COL_HEADER_ODD_STYLE_IDX).getS();
        long evenDateTitleStyle = dateTitleRow.getC().get(COL_HEADER_EVEN_STYLE_IDX).getS();

        long revenueValueStyle = rows.get(0).getC().get(0).getS();
        // last column of each period contains vertical black border at right side
        long lastRevenueTypeInDateHasRightBorderStyle = rows.get(0).getC().get(1).getS();

        Row revenueTypesRow = rows.get(ROW_SUBHEADER_IDX);

        // Initializing structure for merging cells
        CTMergeCells mergeCells = contents.getMergeCells();
        if (mergeCells == null) {
            mergeCells = new CTMergeCells();
            contents.setMergeCells(mergeCells);
        }
        int columnGroupIndex = 0;
        BidiMap<Integer, String> ordersToRevenues = revenueTypeOrders.inverseBidiMap();

        for (Date date : dates) {
            long style = ++columnGroupIndex % 2 == 0 ? evenDateTitleStyle : oddDateTitleStyle;
            boolean firstColumnForDate = true;
            CellReference decorativeMergeBegin = null;
            CellReference decorativeMergeEnd = null;
            CellReference dateMergeBegin = null;
            CellReference dateMergeEnd = null;
            CellReference monthSummaryMergeBegin = null;
            CellReference monthSummaryMergeEnd = null;
            Cell monthSumCell = null; // Only first cell of period contains formula for sum

            for (Integer order :
                    ordersToRevenues.keySet()) {

                // Filling revenue types header
                String revenueTypeName = ordersToRevenues.get(order);

                Cell revenueTypeCell = createFormattedCell(revenueTypesRow.getC().get(COL_REFERENCE_SUBHEADER_IDX));
                revenueTypeCell.setT(STCellType.STR);
                revenueTypeCell.setV(revenueTypeName);
                revenueTypesRow.getC().add(revenueTypeCell);

                // Filling period header
                Cell headerCell = createFormattedCell(dateTitleRow.getC().get(COL_REFERENCE_HEADER_IDX));
                headerCell.setParent(dateTitleRow);
                headerCell.setT(STCellType.STR);
                headerCell.setS(style);
                dateTitleRow.getC().add(headerCell);

                // Creating red decorative cell
                createFormattedCellAppendingToRow(decorativeRow);

                // Creating cell with summary for period
                Cell msc = createFormattedCellAppendingToRow(monthSummaryRow);

                if (firstColumnForDate) {
                    headerCell.setV(new SimpleDateFormat("yyyy - MM", Locale.US).format(date));
                    dateMergeBegin = createCellRef(sheetName, dateTitleRow);
                    decorativeMergeBegin = createCellRef(sheetName, decorativeRow);
                    monthSummaryMergeBegin = createCellRef(sheetName, monthSummaryRow);
                    monthSumCell = msc;
                }

                firstColumnForDate = false;
                dateMergeEnd = createCellRef(sheetName, dateTitleRow);
                decorativeMergeEnd = createCellRef(sheetName, decorativeRow);
                monthSummaryMergeEnd = createCellRef(sheetName, monthSummaryRow);
            }
            CTMergeCell mc = new CTMergeCell();
            mc.setRef(getStrRef(dateMergeBegin, dateMergeEnd));
            mergeCells.getMergeCell().add(mc);

            mc = new CTMergeCell();
            mc.setRef(getStrRef(decorativeMergeBegin, decorativeMergeEnd));
            mergeCells.getMergeCell().add(mc);

            mc = new CTMergeCell();
            mc.setRef(getStrRef(monthSummaryMergeBegin, monthSummaryMergeEnd));
            mergeCells.getMergeCell().add(mc);

            if (monthSumCell != null) {
                int summaryRowIdx = Math.toIntExact(rows.get(ROW_SUMMARY_IDX).getR());
                CTCellFormula formula = new CTCellFormula();
                String monthRange = getStrRef(
                        new CellReference(sheetName, summaryRowIdx, monthSummaryMergeBegin.getColumn()),
                        new CellReference(sheetName, summaryRowIdx, monthSummaryMergeEnd.getColumn()));
                formula.setValue("SUM(" + monthRange + ")");
                monthSumCell.setF(formula);
            }
        }

        // Setup AutoFilters (NB: these settings does not work well in LibreOffice)
        setupAutoFilter(sheetName, contents, revenueTypesRow);

        for (Account account :
                orderedAccounts) {
            Row row = createFormattedRow(referenceRow);
            row.setR((long) rows.size());
            rows.add(row);

            // Filling account information for each row
            addAccountInfo(row, account, lastRevenueTypeInDateHasRightBorderStyle);

            // iterating over all data columns
            for (Date date : dates) {
                Cell lastCell = null;
                for (Integer order :
                        ordersToRevenues.keySet()) {
                    String revenueTypeName = ordersToRevenues.get(order);
                    // account, revenueTypeName, date

                    List<Cell> c = row.getC();

                    Cell dataCell = new Cell();
                    dataCell.setParent(row);
                    dataCell.setT(STCellType.N);
                    c.add(dataCell);
                    dataCell.setV("0");
                    dataCell.setS(revenueValueStyle);

                    List<HorizontalPosition> existingCoords = coordinates.get(account);
                    for (HorizontalPosition horcoord : existingCoords) {

                        if (date.equals(horcoord.getDate()) && revenueTypeName.equals(horcoord.getName())) {
                            // must be existed in cells
                            ReportCell reportCell = findCell(account, revenueTypeName, date);
                            if (reportCell == null) {
                                throw new NullPointerException("Cell not found! account = "
                                        + account + ", revenue type = " + revenueTypeName + ", date = " + date);
                            }
                            dataCell.setV(reportCell.getValueNumber().toString());
                            break;
                        }
                    }
                    lastCell = dataCell;
                }
                // Set black vertical line border for each period
                if (lastCell != null) {
                    lastCell.setS(lastRevenueTypeInDateHasRightBorderStyle);
                }
            }
        }

        // Summary
        Row summaryRow = rows.get(ROW_SUMMARY_IDX);
        Row summaryStrategicRow = rows.get(ROW_SUMMARY_STRATEGIC_IDX);
        Row summaryKeyRow = rows.get(ROW_SUMMARY_KEY_IDX);
        Row summaryOtherRow = rows.get(ROW_SUMMARY_OTHER_IDX);

        for (Date date : dates) {
            for (Integer order :
                    ordersToRevenues.keySet()) {
                String revenueTypeName = ordersToRevenues.get(order);

/*
 * The block below was intended for calculating total for each column.
 * After adopting of Excel native formulas was made there is no necessity to calculate total here.
 */
//                BigDecimal total = BigDecimal.ZERO;
//                for (Account account : orderedAccounts) {
//                    ReportCell cell = findCell(account, revenueTypeName, date);
//                    if (cell != null) {
//                        total = total.add(cell.getValueNumber());
//                    }
//                }

                String criteriaColumn = "A" + rows.get(ROW_FIRST_DATA_IDX).getR() + ":A" + (rows.size() -1 );
                createSummaryFormulaCell(sheetName, rows, summaryRow, "SUBTOTAL(109,");
                createSummaryFormulaCell(sheetName, rows, summaryStrategicRow, "SUMIF(" + criteriaColumn +", \"Strategic\",");
                createSummaryFormulaCell(sheetName, rows, summaryKeyRow, "SUMIF(" + criteriaColumn +", \"Key\",");
                createSummaryFormulaCell(sheetName, rows, summaryOtherRow, "SUMIF(" + criteriaColumn +", \"Other\",");
            }
        }

        signReport(rows.get(SIGN_REPORT_ROW).getC().get(SIGN_REPORT_COL), (Date) params.get(PARAMS_THRESHOLD_DATE), (RecordType) params.get(PARAMS_MODE));
    }

    private void createSummaryFormulaCell(String sheetName, List<Row> rows, Row summaryRow, String formulaPrefix) {
        Row firstDataRow = rows.get(ROW_FIRST_DATA_IDX);
        Cell totalCell = createFormattedCellAppendingToRow(summaryRow);
        CellReference x1 = createCellRef(sheetName, firstDataRow, summaryRow.getC().size());
        CellReference x2 = new CellReference(sheetName, Math.toIntExact(rows.size() - 1), summaryRow.getC().size());
        CTCellFormula formula = new CTCellFormula();
        formula.setValue(formulaPrefix + getStrRef(x1, x2) + ")");
        totalCell.setF(formula);
    }

    private static CellReference createCellRef(String sheetName, Row row, int col) {
        return new CellReference(sheetName, Math.toIntExact(row.getR()), col);
    }

    private static CellReference createCellRef(String sheetName, Row row) {
        return new CellReference(sheetName, Math.toIntExact(row.getR()), row.getC().size());
    }

    private static String getStrRef(CellReference begin, CellReference end) {
        return begin.toReference() + ":" + end.toReference();
    }

    private void setupAutoFilter(String sheetName, Worksheet contents, Row filterRow) {
        CellReference cr1 = new CellReference(sheetName, Math.toIntExact(filterRow.getR()), 1);
        CellReference cr2 = new CellReference(sheetName, Math.toIntExact(filterRow.getR()), filterRow.getC().size());
        CTAutoFilter autoFilter = contents.getAutoFilter();
        if (autoFilter == null) {
            autoFilter = new CTAutoFilter();
            contents.setAutoFilter(autoFilter);
        }
        autoFilter.setRef(cr1.toReference() + ":" + cr2.toReference());
    }

    private static void addAccountInfo(Row row, Account account, long lastRowStyle) {
        List<Cell> c = row.getC();

        // account info
        for (int i = 0; i < ACCOUNT_INFO_COLUMNS; ++i) {
            Cell accountCell = new Cell();
            accountCell.setParent(row);
            accountCell.setT(STCellType.STR);
            switch (i) {
                case 0:
                    accountCell.setV(account.getType());
                    break;
                case 1:
                    accountCell.setV(account.getParent());
                    break;
                case 2:
                    accountCell.setV(account.getCustomer());
                    break;
                case 3:
                    accountCell.setV(account.getAccountManager());
                    break;
                case 4:
                    accountCell.setV(account.getBusinessModel());
                    break;
                case 5:
                    accountCell.setV(account.getApplicationType());
                    accountCell.setS(lastRowStyle);
                    break;
                default:
                    accountCell.setV("");
                    break;
            }
            c.add(accountCell);
        }
    }

    private @Nullable
    ReportCell findCell(Account account, String revenueTypeName, Date date) {
        return reportCells.stream().filter(dc -> account.equals(dc.getCoordinates().getRow())
                && revenueTypeName.equals(dc.getCoordinates().getColumn().getName())
                && date.equals(dc.getCoordinates().getColumn().getDate())
        ).findFirst().orElse(null);
    }

    private Row createFormattedRow(Row referenceRow) {
        Row row = Context.getsmlObjectFactory().createRow();
        row.setHt(referenceRow.getHt());
        row.setExtLst(referenceRow.getExtLst());
        row.setOutlineLevel(referenceRow.getOutlineLevel());
        row.setCustomFormat(referenceRow.isCustomFormat());
        row.setHidden(referenceRow.isHidden());
        row.setPh(referenceRow.isPh());
        row.setCollapsed(referenceRow.isCollapsed());
        row.setCustomHeight(referenceRow.isCustomHeight());
        row.setThickBot(referenceRow.isThickBot());
        row.setThickTop(referenceRow.isThickTop());
        row.setS(referenceRow.getS());
        return row;
    }

    private Cell createFormattedCellAppendingToRow(Row row) {
        Cell newCell = createFormattedCell(row.getC().get(row.getC().size() - 1));
        newCell.setParent(row);
        row.getC().add(newCell);
        return newCell;
    }

    private Cell createFormattedCell(Cell referenceCell) {
        Cell cell = Context.getsmlObjectFactory().createCell();
        cell.setCm(referenceCell.getCm());
        cell.setVm(referenceCell.getVm());
        cell.setF(referenceCell.getF());
        cell.setIs(referenceCell.getIs());
        cell.setT(referenceCell.getT());
        cell.setPh(referenceCell.isPh());
        cell.setS(referenceCell.getS());
        cell.setV(referenceCell.getV());
        cell.setParent(referenceCell.getParent());
        return cell;
    }

    private static Account getAccount(BandData dataElement) {
        Map<String, Object> data = dataElement.getData();
        return new Account(
                (String) data.getOrDefault(ACCOUNT_TYPE_FIELD, "---"),
                (String) data.get(ACCOUNT_PARENT_FIELD),
                (String) data.getOrDefault(ACCOUNT_CUSTOMER_FIELD, "---"),
                (String) data.getOrDefault(ACCOUNT_MANAGER_FIELD, ""),
                (String) data.getOrDefault(ACCOUNT_BUSINESS_MODEL_FIELD, "n/a"),
                (String) data.getOrDefault(ACCOUNT_APPLICATION_TYPE_FIELD, "n/a"),
                (Integer) data.getOrDefault(ACCOUNT_ORDER_FIELD, 0)
        );
    }

    private static HorizontalPosition getHorizontalPosition(BandData dataElement) {
        Map<String, Object> data = dataElement.getData();
        return new HorizontalPosition(
                (String) data.get(REVENUE_TYPE_NAME_FIELD),
                (Integer) data.get(REVENUE_TYPE_ORDER_FIELD),
                (Date) data.get(REVENUE_PERIOD_FIELD)
        );
    }

    private void signReport(Cell cell, Date dateThreshold, RecordType mode) {
        String userName = "unidentified";
        try {
            userName = AppBeans.get(UserSessionSource.class).getUserSession().getUser().getName();
        } catch (Exception ex) {
            LOGGER.error("Could not get user's name from userSession", ex);
        }
        String modeStr = "n/a";
        try {
            modeStr = AppBeans.get(Messages.class).getMessage(mode);
        } catch (IllegalStateException ex) {
            LOGGER.error("Could not get string for mode", ex);
        }
        String sb = "generated by " +
                userName + " at " + LocalDateTime.now().format(DateTimeFormatter.ofPattern("dd.MM.yy HH:mm", Locale.US)) +
                " (mode: \"" + modeStr + '"' +
                ", threshold: " + new SimpleDateFormat("dd.MM.yy", Locale.US).format(dateThreshold) + ")";

        cell.setT(STCellType.STR);
        cell.setV(sb);

        LOGGER.info("SalesTeamReport " + sb);
    }

}
