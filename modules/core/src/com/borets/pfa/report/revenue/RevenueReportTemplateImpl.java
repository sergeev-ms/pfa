package com.borets.pfa.report.revenue;

import com.borets.pfa.entity.activity.RecordType;
import com.borets.pfa.report.custom.Account;
import com.borets.pfa.report.custom.AccountBasedReportTemplate;
import com.borets.pfa.report.custom.HorizontalPosition;
import com.borets.pfa.report.custom.ReportCell;
import com.haulmont.yarg.formatters.impl.xlsx.CellReference;
import com.haulmont.yarg.formatters.impl.xlsx.Document;
import com.haulmont.yarg.structure.BandData;
import org.apache.commons.collections4.BidiMap;
import org.docx4j.openpackaging.exceptions.Docx4JException;
import org.docx4j.openpackaging.parts.SpreadsheetML.WorksheetPart;
import org.xlsx4j.sml.CTCellFormula;
import org.xlsx4j.sml.CTMergeCell;
import org.xlsx4j.sml.CTMergeCells;
import org.xlsx4j.sml.CTSheetCalcPr;
import org.xlsx4j.sml.Cell;
import org.xlsx4j.sml.Row;
import org.xlsx4j.sml.STCellType;
import org.xlsx4j.sml.SheetData;
import org.xlsx4j.sml.Worksheet;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Locale;
import java.util.Map;

/**
 * Revenue Report data and logic container.
 */
public class RevenueReportTemplateImpl extends AccountBasedReportTemplate {

    /**
     * Amount of columns related to Account Description (Account Type, Parent, Customer, Manager and so on).
     */
    private static final int ACCOUNT_INFO_COLUMNS = 6;

    /**
     * Result DataSet SQL column names.
     */
    private static final String REVENUE_TYPE_NAME_FIELD = "REVENUE_TYPE_NAME";
    private static final String REVENUE_TYPE_ORDER_FIELD = "REVENUE_TYPE_ORDER";
    private static final String REVENUE_VALUE = "REVENUE";

    /**
     * Indices of columns and rows (these values must be correlated with concrete Excel template).
     */
    private static final int ROW_DECORATIVE_IDX = 1;
    private static final int ROW_HEADER_IDX = 2;
    private static final int ROW_SUBHEADER_IDX = 8;
    private static final int ROW_FIRST_DATA_IDX = 9;
    private static final int ROW_SUMMARY_PER_MONTH_IDX = 3;
    private static final int ROW_SUMMARY_IDX = 4;
    private static final int ROW_SUMMARY_STRATEGIC_IDX = 5;
    private static final int ROW_SUMMARY_KEY_IDX = 6;
    private static final int ROW_SUMMARY_OTHER_IDX = 7;
    private static final int COL_HEADER_ODD_STYLE_IDX = 1;
    private static final int COL_HEADER_EVEN_STYLE_IDX = 3;
    private static final int COL_REFERENCE_HEADER_IDX = 3;
    private static final int COL_REFERENCE_SUBHEADER_IDX = 0;

    /**
     * Coordinates of the cell where report signature "Generated by..." will be placed in.
     */
    private static final int SIGN_REPORT_ROW = 0;
    private static final int SIGN_REPORT_COL = 3;
    @Override
    protected void preProcessDataElement(String bandName, BandData dataElement) {
        Map<String, Object> data = dataElement.getData();
        String revenueType = (String) data.get(REVENUE_TYPE_NAME_FIELD);
        // map revenue types to their orders
        columnNamesToOrders.computeIfAbsent(revenueType, String -> (Integer) data.get(REVENUE_TYPE_ORDER_FIELD));
        // get distinct dates of report
        Date d = (Date) data.get(PERIOD_FIELD);
        if (!dates.contains(d)) {
            dates.add(d);
        }
    }

    @Override
    protected void processDataElement(String bandName, BandData dataElement) {
        if (DATA_BAND_NAME.equals(bandName)) {
            Account x = Account.from(dataElement);
            coordinates.computeIfAbsent(x, Account -> new ArrayList<>());
            List<HorizontalPosition> horizontalPositions = coordinates.get(x);
            HorizontalPosition y = getHorizontalPosition(dataElement);
            if (!horizontalPositions.contains(y)) {
                horizontalPositions.add(y);
            }
            // Getting existing objects instead of newly created
            for (Account a :
                    coordinates.keySet()) {
                if (a.equals(x)) {
                    x = a;
                    break;
                }
            }
            for (HorizontalPosition a :
                    coordinates.get(x)) {
                if (a.equals(y)) {
                    y = a;
                    break;
                }
            }
            // Create new cell
            ReportCell<Account> reportCell = ReportCell.newDigit(dataElement.getData().getOrDefault(REVENUE_VALUE, 0), x, y);
            reportCells.add(reportCell);
        }
    }

    @Override
    protected void generateReport(List<Document.SheetWrapper> sheetWrappers) throws Docx4JException {
        Document.SheetWrapper sheetWrapper = sheetWrappers.get(0);
        String sheetName = sheetWrapper.getName();
        WorksheetPart worksheetPart = sheetWrapper.getWorksheet();
        Worksheet contents = worksheetPart.getContents();
        SheetData sheetData = contents.getSheetData();
        List<Row> rows = sheetData.getRow();
        CTSheetCalcPr ctSheetCalcPr = new CTSheetCalcPr();
        ctSheetCalcPr.setFullCalcOnLoad(true);
        contents.setSheetCalcPr(ctSheetCalcPr);

        Row referenceRow = rows.get(rows.size() - 1);

        // Headers
        Row decorativeRow = rows.get(ROW_DECORATIVE_IDX); // Upper red line without values
        Row dateTitleRow = rows.get(ROW_HEADER_IDX); // Period titles: "Apr 2022", "May 2022", ...
        Row monthSummaryRow = rows.get(ROW_SUMMARY_PER_MONTH_IDX); // Summaries for period

        // Styles for period interleaving (i.g. lighter/darker)
        long oddDateTitleStyle = dateTitleRow.getC().get(COL_HEADER_ODD_STYLE_IDX).getS();
        long evenDateTitleStyle = dateTitleRow.getC().get(COL_HEADER_EVEN_STYLE_IDX).getS();

        long revenueValueStyle = rows.get(0).getC().get(0).getS();
        // last column of each period contains vertical black border at right side
        long lastRevenueTypeInDateHasRightBorderStyle = rows.get(0).getC().get(1).getS();
        long accountSectionLastColumnStyle = rows.get(0).getC().get(2).getS();

        Row revenueTypesRow = rows.get(ROW_SUBHEADER_IDX);

        // Initializing structure for merging cells
        CTMergeCells mergeCells = contents.getMergeCells();
        if (mergeCells == null) {
            mergeCells = new CTMergeCells();
            contents.setMergeCells(mergeCells);
        }
        int columnGroupIndex = 0;
        BidiMap<Integer, String> ordersToRevenues = columnNamesToOrders.inverseBidiMap();

        for (Date date : dates) {
            long style = ++columnGroupIndex % 2 == 0 ? evenDateTitleStyle : oddDateTitleStyle;
            boolean firstColumnForDate = true;
            CellReference decorativeMergeBegin = null;
            CellReference decorativeMergeEnd = null;
            CellReference dateMergeBegin = null;
            CellReference dateMergeEnd = null;
            CellReference monthSummaryMergeBegin = null;
            CellReference monthSummaryMergeEnd = null;
            Cell monthSumCell = null; // Only first cell of period contains formula for sum

            for (Integer order :
                    ordersToRevenues.keySet()) {

                // Filling revenue types header
                String revenueTypeName = ordersToRevenues.get(order);

                Cell revenueTypeCell = createFormattedCell(revenueTypesRow.getC().get(COL_REFERENCE_SUBHEADER_IDX));
                revenueTypeCell.setT(STCellType.STR);
                revenueTypeCell.setV(revenueTypeName);
                revenueTypesRow.getC().add(revenueTypeCell);

                // Filling period header
                Cell headerCell = createFormattedCell(dateTitleRow.getC().get(COL_REFERENCE_HEADER_IDX));
                headerCell.setParent(dateTitleRow);
                headerCell.setT(STCellType.STR);
                headerCell.setS(style);
                dateTitleRow.getC().add(headerCell);

                // Creating red decorative cell
                createFormattedCellAppendingToRow(decorativeRow);

                // Creating cell with summary for period
                Cell msc = createFormattedCellAppendingToRow(monthSummaryRow);

                if (firstColumnForDate) {
                    headerCell.setV(new SimpleDateFormat("yyyy - MM", Locale.US).format(date));
                    dateMergeBegin = createCellRef(sheetName, dateTitleRow);
                    decorativeMergeBegin = createCellRef(sheetName, decorativeRow);
                    monthSummaryMergeBegin = createCellRef(sheetName, monthSummaryRow);
                    monthSumCell = msc;
                }

                firstColumnForDate = false;
                dateMergeEnd = createCellRef(sheetName, dateTitleRow);
                decorativeMergeEnd = createCellRef(sheetName, decorativeRow);
                monthSummaryMergeEnd = createCellRef(sheetName, monthSummaryRow);
            }
            CTMergeCell mc = new CTMergeCell();
            mc.setRef(getStrRef(dateMergeBegin, dateMergeEnd));
            mergeCells.getMergeCell().add(mc);

            mc = new CTMergeCell();
            mc.setRef(getStrRef(decorativeMergeBegin, decorativeMergeEnd));
            mergeCells.getMergeCell().add(mc);

            mc = new CTMergeCell();
            mc.setRef(getStrRef(monthSummaryMergeBegin, monthSummaryMergeEnd));
            mergeCells.getMergeCell().add(mc);

            if (monthSumCell != null) {
                int summaryRowIdx = Math.toIntExact(rows.get(ROW_SUMMARY_IDX).getR());
                CTCellFormula formula = new CTCellFormula();
                String monthRange = getStrRef(
                        new CellReference(sheetName, summaryRowIdx, monthSummaryMergeBegin.getColumn()),
                        new CellReference(sheetName, summaryRowIdx, monthSummaryMergeEnd.getColumn()));
                formula.setValue("SUM(" + monthRange + ")");
                monthSumCell.setF(formula);
            }
        }

        // Setup AutoFilters (NB: these settings does not work well in LibreOffice)
        setupAutoFilter(sheetName, contents, revenueTypesRow);

        for (Account account :
                getOrderedAccounts()) {
            Row row = createFormattedRow(referenceRow);
            row.setR((long) rows.size());
            rows.add(row);

            // Filling account information for each row
            addAccountInfo(row, ACCOUNT_INFO_COLUMNS, account, accountSectionLastColumnStyle, null);

            // iterating over all data columns
            for (Date date : dates) {
                Cell lastCell = null;
                for (Integer order :
                        ordersToRevenues.keySet()) {
                    String revenueTypeName = ordersToRevenues.get(order);
                    // account, revenueTypeName, date

                    List<Cell> c = row.getC();

                    Cell dataCell = new Cell();
                    dataCell.setParent(row);
                    dataCell.setT(STCellType.N);
                    c.add(dataCell);
                    dataCell.setV("0");
                    dataCell.setS(revenueValueStyle);

                    List<HorizontalPosition> existingCoords = coordinates.get(account);
                    for (HorizontalPosition horcoord : existingCoords) {

                        if (date.equals(horcoord.getDate()) && revenueTypeName.equals(horcoord.getName())) {
                            // must be existed in cells
                            ReportCell reportCell = findCell(account, revenueTypeName, date);
                            if (reportCell == null) {
                                throw new NullPointerException("Cell not found! account = "
                                        + account + ", revenue type = " + revenueTypeName + ", date = " + date);
                            }
                            dataCell.setV(reportCell.getValueNumber().toString());
                            break;
                        }
                    }
                    lastCell = dataCell;
                }
                // Set black vertical line border for each period
                if (lastCell != null) {
                    lastCell.setS(lastRevenueTypeInDateHasRightBorderStyle);
                }
            }
        }

        // Summary
        Row summaryRow = rows.get(ROW_SUMMARY_IDX);
        Row summaryStrategicRow = rows.get(ROW_SUMMARY_STRATEGIC_IDX);
        Row summaryKeyRow = rows.get(ROW_SUMMARY_KEY_IDX);
        Row summaryOtherRow = rows.get(ROW_SUMMARY_OTHER_IDX);

        for (Date date : dates) {
            for (Integer order :
                    ordersToRevenues.keySet()) {
                String revenueTypeName = ordersToRevenues.get(order);

/*
 * The block below was intended for calculating total for each column.
 * After adopting of Excel native formulas was made there is no necessity to calculate total here.
 */
//                BigDecimal total = BigDecimal.ZERO;
//                for (Account account : orderedAccounts) {
//                    ReportCell cell = findCell(account, revenueTypeName, date);
//                    if (cell != null) {
//                        total = total.add(cell.getValueNumber());
//                    }
//                }

                //String criteriaColumn = "A" + rows.get(ROW_FIRST_DATA_IDX).getR() + ":A" + (rows.size() -1 );
                createSummaryFormulaCell(sheetName, rows, ROW_FIRST_DATA_IDX, summaryRow, "SUBTOTAL(109,");
                createSummaryFormulaCell(sheetName, rows, ROW_FIRST_DATA_IDX, summaryStrategicRow, null /*"SUMIF(" + criteriaColumn +", \"Strategic\","*/);
                createSummaryFormulaCell(sheetName, rows, ROW_FIRST_DATA_IDX, summaryKeyRow, null /*"SUMIF(" + criteriaColumn +", \"Key\","*/);
                createSummaryFormulaCell(sheetName, rows, ROW_FIRST_DATA_IDX, summaryOtherRow, null /*"SUMIF(" + criteriaColumn +", \"Other\","*/);
            }
        }

        signReport(rows.get(SIGN_REPORT_ROW).getC().get(SIGN_REPORT_COL), (Date) params.get(PARAMS_THRESHOLD_DATE), (RecordType) params.get(PARAMS_MODE));
    }

    private static HorizontalPosition getHorizontalPosition(BandData dataElement) {
        Map<String, Object> data = dataElement.getData();
        return new HorizontalPosition(
                (String) data.get(REVENUE_TYPE_NAME_FIELD),
                (Integer) data.get(REVENUE_TYPE_ORDER_FIELD),
                (Date) data.get(PERIOD_FIELD)
        );
    }

}
