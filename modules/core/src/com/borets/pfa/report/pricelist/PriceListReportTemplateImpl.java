package com.borets.pfa.report.pricelist;

import com.borets.pfa.entity.activity.RecordType;
import com.borets.pfa.report.custom.Account;
import com.borets.pfa.report.custom.AccountBasedReportTemplate;
import com.borets.pfa.report.custom.HorizontalPosition;
import com.borets.pfa.report.custom.ReportCell;
import com.haulmont.yarg.formatters.impl.xlsx.CellReference;
import com.haulmont.yarg.formatters.impl.xlsx.Document;
import com.haulmont.yarg.structure.BandData;
import org.apache.commons.collections4.BidiMap;
import org.docx4j.openpackaging.exceptions.Docx4JException;
import org.docx4j.openpackaging.parts.SpreadsheetML.WorksheetPart;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.xlsx4j.sml.CTMergeCell;
import org.xlsx4j.sml.CTMergeCells;
import org.xlsx4j.sml.CTSheetCalcPr;
import org.xlsx4j.sml.Cell;
import org.xlsx4j.sml.Row;
import org.xlsx4j.sml.STCellType;
import org.xlsx4j.sml.SheetData;
import org.xlsx4j.sml.Worksheet;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;

public class PriceListReportTemplateImpl extends AccountBasedReportTemplate {

    private static final Logger LOGGER = LoggerFactory.getLogger(PriceListReportTemplateImpl.class);

    private static final String FULL_TITLE_NAME_FIELD = "TITLE";
    private static final String FULL_TITLE_ORDER_FIELD = "ORDER";

    /**
     * Amount of columns related to Account Description (Account Type, Parent, Customer, Manager and so on).
     */
    private static final int ACCOUNT_INFO_COLUMNS = 6;

    /**
     * Indices of columns and rows (these values must be correlated with concrete Excel template).
     */
    private static final int ROW_DECORATIVE_IDX = 1;
    private static final int ROW_DATE_IDX = 2;
    private static final int ROW_REVENUE_TITLE_IDX = 3;
    private static final int ROW_ANALYTIC_TITLE_IDX = 4;
    private static final int ROW_FIRST_DATA_IDX = 5;

    private static final int COL_REFERENCE_HEADER_IDX = 3;
    private static final int COL_REFERENCE_SUBHEADER_IDX = 0;

    /**
     * Coordinates of the cell where report signature "Generated by..." will be placed in.
     */
    private static final int SIGN_REPORT_ROW = 0;
    private static final int SIGN_REPORT_COL = 3;

    @Override
    protected void preProcessDataElement(String bandName, BandData dataElement) {
        Map<String, Object> data = dataElement.getData();
        String fullTitle = (String) data.get(FULL_TITLE_NAME_FIELD);
        // map revenue types to their orders
        columnNamesToOrders.computeIfAbsent(fullTitle, String -> (Integer) data.get(FULL_TITLE_ORDER_FIELD));
        // get distinct dates of report
        Date d = (Date) data.get(PERIOD_FIELD);
        if (!dates.contains(d)) {
            dates.add(d);
        }
    }

    @Override
    protected void processDataElement(String bandName, BandData dataElement) {
        if (DATA_BAND_NAME.equals(bandName)) {
            Account account = Account.from(dataElement);
            coordinates.computeIfAbsent(account, Account -> new ArrayList<>());
            List<HorizontalPosition> horizontalPositions = coordinates.get(account);
            HorizontalPosition horizontalPosition = getHorizontalPosition(dataElement);
            if (!horizontalPositions.contains(horizontalPosition)) {
                horizontalPositions.add(horizontalPosition);
            }
            // Getting existing objects instead of newly created
            for (Account a :
                    coordinates.keySet()) {
                if (a.equals(account)) {
                    account = a;
                    break;
                }
            }
            for (HorizontalPosition hp :
                    coordinates.get(account)) {
                if (hp.equals(horizontalPosition)) {
                    horizontalPosition = hp;
                    break;
                }
            }
            // Create new cell
            ReportCell<Account> reportCell = ReportCell.newDigit(dataElement.getData().getOrDefault(CELL_VALUE, 0), account, horizontalPosition);
            reportCells.add(reportCell);
        }
    }

    private static HorizontalPosition getHorizontalPosition(BandData dataElement) {
        Map<String, Object> data = dataElement.getData();
        return new HorizontalPosition(
                (String) data.get(FULL_TITLE_NAME_FIELD),
                (Integer) data.get(FULL_TITLE_ORDER_FIELD),
                (Date) data.get(PERIOD_FIELD)
        );
    }

    @Override
    protected void generateReport(List<Document.SheetWrapper> sheetWrappers) throws Docx4JException {
        Document.SheetWrapper sheetWrapper = sheetWrappers.get(0);
        String sheetName = sheetWrapper.getName();
        WorksheetPart worksheetPart = sheetWrapper.getWorksheet();
        Worksheet contents = worksheetPart.getContents();
        SheetData sheetData = contents.getSheetData();
        List<Row> rows = sheetData.getRow();
        CTSheetCalcPr ctSheetCalcPr = new CTSheetCalcPr();
        ctSheetCalcPr.setFullCalcOnLoad(true);
        contents.setSheetCalcPr(ctSheetCalcPr);

        Row referenceRow = rows.get(rows.size() - 1);

        // Headers
        Row decorativeRow = rows.get(ROW_DECORATIVE_IDX); // Upper red line without values
        Row dateTitleRow = rows.get(ROW_DATE_IDX); // Period titles: "Apr 2022", "May 2022", ...
        Row revenueTitlesRow = rows.get(ROW_REVENUE_TITLE_IDX);
        Row analyticTitlesRow = rows.get(ROW_ANALYTIC_TITLE_IDX);

        // TODO add enumeration
        long valueCellStyle = getStyle("valueCell");
        long valueLastCellForDateStyle = getStyle("valueLastCellForDate");
        long accountCellStyle = getStyle("accountCell");
        long accountLastCellStyle = getStyle("accountLastCell");

        // Initializing structure for merging cells
        CTMergeCells mergeCells = contents.getMergeCells();
        if (mergeCells == null) {
            mergeCells = new CTMergeCells();
            contents.setMergeCells(mergeCells);
        }
        int columnGroupIndex = 0;
        BidiMap<Integer, String> ordersToTitles = columnNamesToOrders.inverseBidiMap();

        for (Date date : dates) {
            boolean firstColumnForDate = true;
            CellReference decorativeMergeBegin = null;
            CellReference decorativeMergeEnd = null;
            CellReference dateMergeBegin = null;
            CellReference dateMergeEnd = null;

            CellReference revenueBegin = null;
            CellReference revenueEnd = null;
            String prevRevenueTitle = null;

            for (Integer order :
                    ordersToTitles.keySet()) {

                // Creating red decorative cell
                createFormattedCellAppendingToRow(decorativeRow);

                // Filling date (period) header
                Cell dateCell = createFormattedCell(dateTitleRow.getC().get(COL_REFERENCE_HEADER_IDX));
                dateCell.setParent(dateTitleRow);
                dateCell.setT(STCellType.STR);
                dateTitleRow.getC().add(dateCell);

                String fullTitle = ordersToTitles.get(order);
                String[] titles = fullTitle.split("##");

                // Filling revenue title header
                String revenueTitle = titles[0];
                Cell revenueTitleCell = createFormattedCell(revenueTitlesRow.getC().get(COL_REFERENCE_SUBHEADER_IDX));
                revenueTitlesRow.getC().add(revenueTitleCell);

                if (Objects.equals(revenueTitle, prevRevenueTitle)) {
                    revenueEnd = createCellRef(sheetName, revenueTitlesRow);
                } else {
                    revenueTitleCell.setT(STCellType.STR);
                    revenueTitleCell.setV(revenueTitle);
                    if (revenueEnd != null && revenueBegin != null
                            && !Objects.equals(revenueBegin.toReference(), revenueEnd.toReference())) {
                        CTMergeCell mc = new CTMergeCell();
                        mc.setRef(getStrRef(revenueBegin, revenueEnd));
                        mergeCells.getMergeCell().add(mc);
                        revenueEnd = null;
                    }
                    revenueBegin = createCellRef(sheetName, revenueTitlesRow);
                }
                prevRevenueTitle = revenueTitle;

                // Filling analytic title header
                String analyticTitle = titles[1];
                Cell analyticTitleCell = createFormattedCell(analyticTitlesRow.getC().get(COL_REFERENCE_SUBHEADER_IDX));
                analyticTitleCell.setT(STCellType.STR);
                analyticTitleCell.setV(analyticTitle);
                analyticTitlesRow.getC().add(analyticTitleCell);

                if (firstColumnForDate) {
                    dateCell.setV(new SimpleDateFormat("yyyy - MM", Locale.US).format(date));
                    dateMergeBegin = createCellRef(sheetName, dateTitleRow);
                    decorativeMergeBegin = createCellRef(sheetName, decorativeRow);
                }

                firstColumnForDate = false;
                dateMergeEnd = createCellRef(sheetName, dateTitleRow);
                decorativeMergeEnd = createCellRef(sheetName, decorativeRow);
            }
            CTMergeCell mc = new CTMergeCell();
            mc.setRef(getStrRef(dateMergeBegin, dateMergeEnd));
            mergeCells.getMergeCell().add(mc);

            mc = new CTMergeCell();
            mc.setRef(getStrRef(decorativeMergeBegin, decorativeMergeEnd));
            mergeCells.getMergeCell().add(mc);
        }

        setupAutoFilter(sheetName, contents, analyticTitlesRow);

        for (Account account :
                getOrderedAccounts()) {
            Row row = createFormattedRow(referenceRow);
            row.setR((long) rows.size());
            rows.add(row);

            // Filling account information for each row
            addAccountInfo(row, ACCOUNT_INFO_COLUMNS, account, accountLastCellStyle, accountCellStyle);

            // iterating over all data columns
            for (Date date : dates) {
                Cell lastCell = null;
                for (Integer order :
                        ordersToTitles.keySet()) {
                    String revenueTypeName = ordersToTitles.get(order);
                    // account, revenueTypeName, date

                    List<Cell> c = row.getC();

                    Cell dataCell = new Cell();
                    dataCell.setParent(row);
                    dataCell.setT(STCellType.N);
                    c.add(dataCell);
                    dataCell.setV("0");
                    dataCell.setS(valueCellStyle);

                    List<HorizontalPosition> existingCoords = coordinates.get(account);
                    for (HorizontalPosition horcoord : existingCoords) {

                        if (date.equals(horcoord.getDate()) && revenueTypeName.equals(horcoord.getName())) {
                            // must be existed in cells
                            ReportCell reportCell = findCell(account, revenueTypeName, date);
                            if (reportCell == null) {
                                throw new NullPointerException("Cell not found! account = "
                                        + account + ", revenue type = " + revenueTypeName + ", date = " + date);
                            }
                            dataCell.setV(reportCell.getValueNumber().toString());
                            break;
                        }
                    }
                    lastCell = dataCell;
                }
                // Set black vertical line border for each period
                if (lastCell != null) {
                    lastCell.setS(valueLastCellForDateStyle);
                }
            }
        }

        signReport(rows.get(SIGN_REPORT_ROW).getC().get(SIGN_REPORT_COL), (Date) params.get(PARAMS_THRESHOLD_DATE), (RecordType) params.get(PARAMS_MODE));
    }
}
