package com.borets.pfa.report.salesteam;

import com.borets.pfa.entity.activity.RecordType;
import com.borets.pfa.report.custom.Account;
import com.borets.pfa.report.custom.AccountBasedReportTemplate;
import com.borets.pfa.report.custom.CustomExcelReportTemplate;
import com.borets.pfa.report.custom.HorizontalPosition;
import com.borets.pfa.report.custom.ReportCell;
import com.haulmont.yarg.formatters.impl.xlsx.CellReference;
import com.haulmont.yarg.formatters.impl.xlsx.Document;
import com.haulmont.yarg.structure.BandData;
import org.apache.commons.collections4.BidiMap;
import org.docx4j.openpackaging.exceptions.Docx4JException;
import org.docx4j.openpackaging.parts.SpreadsheetML.WorksheetPart;
import org.xlsx4j.sml.CTMergeCell;
import org.xlsx4j.sml.CTMergeCells;
import org.xlsx4j.sml.CTSheetCalcPr;
import org.xlsx4j.sml.Cell;
import org.xlsx4j.sml.Row;
import org.xlsx4j.sml.STCellType;
import org.xlsx4j.sml.SheetData;
import org.xlsx4j.sml.Worksheet;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Locale;
import java.util.Map;

public class SalesTeamReportTemplateImpl extends AccountBasedReportTemplate {

    /**
     * Amount of columns related to Account Description (Account Type, Parent, Customer, Manager and so on).
     */
    private static final int ACCOUNT_INFO_COLUMNS = 7;

    private static final String ANALYTIC_TITLE_NAME_FIELD = "ANALYTIC_TITLE";
    private static final String ANALYTIC_TITLE_ORDER_FIELD = "ANALYTIC_ORDER";

    /**
     * Indices of columns and rows (these values must be correlated with concrete Excel template).
     */
    private static final int ROW_DECORATIVE_IDX = 1;
    private static final int ROW_DATE_IDX = 2;
    private static final int ROW_SUMMARY_IDX = 3;
    private static final int ROW_ANALYTIC_TITLE_IDX = 4;
    private static final int ROW_FIRST_DATA_IDX = 5;

    private static final int COL_REFERENCE_HEADER_IDX = 3;
    private static final int COL_REFERENCE_SUBHEADER_IDX = 0;

    /**
     * Coordinates of the cell where report signature "Generated by..." will be placed in.
     */
    private static final int SIGN_REPORT_ROW = 0;
    private static final int SIGN_REPORT_COL = 3;

    @Override
    protected void preProcessDataElement(String bandName, BandData dataElement) {
        Map<String, Object> data = dataElement.getData();
        String analyticTitle = (String) data.get(ANALYTIC_TITLE_NAME_FIELD);
        // map revenue types to their orders
        columnNamesToOrders.computeIfAbsent(analyticTitle, String -> (Integer) data.get(ANALYTIC_TITLE_ORDER_FIELD));
        // get distinct dates of report
        Date d = (Date) data.get(PERIOD_FIELD);
        if (!dates.contains(d)) {
            dates.add(d);
        }
    }

    @Override
    protected void processDataElement(String bandName, BandData dataElement) {
        if (DATA_BAND_NAME.equals(bandName)) {
            Account x = Account.from(dataElement);
            coordinates.computeIfAbsent(x, Account -> new ArrayList<>());
            List<HorizontalPosition> horizontalPositions = coordinates.get(x);
            HorizontalPosition y = getHorizontalPosition(dataElement);
            if (!horizontalPositions.contains(y)) {
                horizontalPositions.add(y);
            }
            // Getting existing objects instead of newly created
            for (Account a :
                    coordinates.keySet()) {
                if (a.equals(x)) {
                    x = a;
                    break;
                }
            }
            for (HorizontalPosition a :
                    coordinates.get(x)) {
                if (a.equals(y)) {
                    y = a;
                    break;
                }
            }
            // Create new cell
            ReportCell reportCell = ReportCell.newDigit(dataElement.getData().getOrDefault(CELL_VALUE, 0), x, y);
            reportCells.add(reportCell);
        }
    }

    private static HorizontalPosition getHorizontalPosition(BandData dataElement) {
        Map<String, Object> data = dataElement.getData();
        return new HorizontalPosition(
                (String) data.get(ANALYTIC_TITLE_NAME_FIELD),
                (Integer) data.get(ANALYTIC_TITLE_ORDER_FIELD),
                (Date) data.get(PERIOD_FIELD)
        );
    }

    @Override
    protected void generateReport(List<Document.SheetWrapper> sheetWrappers) throws Docx4JException {
        Document.SheetWrapper sheetWrapper = sheetWrappers.get(0);
        String sheetName = sheetWrapper.getName();
        WorksheetPart worksheetPart = sheetWrapper.getWorksheet();
        Worksheet contents = worksheetPart.getContents();
        SheetData sheetData = contents.getSheetData();
        List<Row> rows = sheetData.getRow();
        CTSheetCalcPr ctSheetCalcPr = new CTSheetCalcPr();
        ctSheetCalcPr.setFullCalcOnLoad(true);
        contents.setSheetCalcPr(ctSheetCalcPr);

        Row referenceRow = rows.get(rows.size() - 1);

        // Headers
        Row decorativeRow = rows.get(ROW_DECORATIVE_IDX); // Upper red line without values
        Row dateTitleRow = rows.get(ROW_DATE_IDX); // Period titles: "Apr 2022", "May 2022", ...
        Row analyticTitlesRow = rows.get(ROW_ANALYTIC_TITLE_IDX);

        long valueStyle = rows.get(0).getC().get(0).getS();
        // last column of each period contains vertical black border at right side
        long lastValueInPeriodStyle = rows.get(0).getC().get(1).getS();
        long accountSectionStyle = rows.get(0).getC().get(5).getS();
        long accountSectionLastColumnStyle = rows.get(0).getC().get(6).getS();

        // Initializing structure for merging cells
        CTMergeCells mergeCells = contents.getMergeCells();
        if (mergeCells == null) {
            mergeCells = new CTMergeCells();
            contents.setMergeCells(mergeCells);
        }
        int columnGroupIndex = 0;
        BidiMap<Integer, String> ordersToAnalyticTitles = columnNamesToOrders.inverseBidiMap();

        for (Date date : dates) {
            boolean firstColumnForDate = true;
            CellReference decorativeMergeBegin = null;
            CellReference decorativeMergeEnd = null;
            CellReference dateMergeBegin = null;
            CellReference dateMergeEnd = null;

            for (Integer order :
                    ordersToAnalyticTitles.keySet()) {

                // Creating red decorative cell
                createFormattedCellAppendingToRow(decorativeRow);

                // Filling date (period) header
                Cell dateCell = createFormattedCell(dateTitleRow.getC().get(COL_REFERENCE_HEADER_IDX));
                dateCell.setParent(dateTitleRow);
                dateCell.setT(STCellType.STR);
                dateTitleRow.getC().add(dateCell);

                // Filling analytic title header
                String analyticTitleName = ordersToAnalyticTitles.get(order);
                Cell analyticTitleCell = createFormattedCell(analyticTitlesRow.getC().get(COL_REFERENCE_SUBHEADER_IDX));
                analyticTitleCell.setT(STCellType.STR);
                analyticTitleCell.setV(analyticTitleName);
                analyticTitlesRow.getC().add(analyticTitleCell);

                if (firstColumnForDate) {
                    dateCell.setV(new SimpleDateFormat("yyyy - MM", Locale.US).format(date));
                    dateMergeBegin = createCellRef(sheetName, dateTitleRow);
                    decorativeMergeBegin = createCellRef(sheetName, decorativeRow);
                }

                firstColumnForDate = false;
                dateMergeEnd = createCellRef(sheetName, dateTitleRow);
                decorativeMergeEnd = createCellRef(sheetName, decorativeRow);
            }
            CTMergeCell mc = new CTMergeCell();
            mc.setRef(getStrRef(dateMergeBegin, dateMergeEnd));
            mergeCells.getMergeCell().add(mc);

            mc = new CTMergeCell();
            mc.setRef(getStrRef(decorativeMergeBegin, decorativeMergeEnd));
            mergeCells.getMergeCell().add(mc);
        }

        // Setup AutoFilters (NB: these settings does not work well in LibreOffice)
        setupAutoFilter(sheetName, contents, analyticTitlesRow);

        for (Account account :
                getOrderedAccounts()) {
            Row row = createFormattedRow(referenceRow);
            row.setR((long) rows.size());
            rows.add(row);

            // Filling account information for each row
            addAccountInfo(row, ACCOUNT_INFO_COLUMNS, account, accountSectionLastColumnStyle, accountSectionStyle);

            // iterating over all data columns
            for (Date date : dates) {
                Cell lastCell = null;
                for (Integer order :
                        ordersToAnalyticTitles.keySet()) {
                    String revenueTypeName = ordersToAnalyticTitles.get(order);
                    // account, revenueTypeName, date

                    List<Cell> c = row.getC();

                    Cell dataCell = new Cell();
                    dataCell.setParent(row);
                    dataCell.setT(STCellType.N);
                    c.add(dataCell);
                    dataCell.setV("0");
                    dataCell.setS(valueStyle);

                    List<HorizontalPosition> existingCoords = coordinates.get(account);
                    for (HorizontalPosition horcoord : existingCoords) {

                        if (date.equals(horcoord.getDate()) && revenueTypeName.equals(horcoord.getName())) {
                            // must be existed in cells
                            ReportCell reportCell = findCell(account, revenueTypeName, date);
                            if (reportCell == null) {
                                throw new NullPointerException("Cell not found! account = "
                                        + account + ", revenue type = " + revenueTypeName + ", date = " + date);
                            }
                            dataCell.setV(reportCell.getValueNumber().toString());
                            break;
                        }
                    }
                    lastCell = dataCell;
                }
                // Set black vertical line border for each period
                if (lastCell != null) {
                    lastCell.setS(lastValueInPeriodStyle);
                }
            }
        }

        // Summary
        Row summaryRow = rows.get(ROW_SUMMARY_IDX);
        for (Date date : dates) {
            for (Integer order :
                    ordersToAnalyticTitles.keySet()) {
                createSummaryFormulaCell(sheetName, rows, ROW_FIRST_DATA_IDX, summaryRow, "SUBTOTAL(109,");
            }
        }
        signReport(rows.get(SIGN_REPORT_ROW).getC().get(SIGN_REPORT_COL), (Date) params.get(PARAMS_THRESHOLD_DATE), (RecordType) params.get(PARAMS_MODE));
    }

}
